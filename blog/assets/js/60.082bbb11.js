(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{619:function(v,_,e){"use strict";e.r(_);var t=e(22),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"从输入url到页面展示，这中间发生了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到页面展示，这中间发生了什么"}},[v._v("#")]),v._v(" 从输入URL到页面展示，这中间发生了什么")]),v._v(" "),e("h2",{attrs:{id:"用户输入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用户输入"}},[v._v("#")]),v._v(" 用户输入")]),v._v(" "),e("p",[v._v("用户输入url并回车\n地址栏会根据输入的关键字是搜索内容还是请求的URL，\n如果是搜索内容，则浏览器会通过默认搜索引擎来搜索相关内容，\n如果是url请求地址，"),e("code",[v._v("浏览器进程检查url，组装协议，构成完整的url")])]),v._v(" "),e("h2",{attrs:{id:"url请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#url请求"}},[v._v("#")]),v._v(" URL请求")]),v._v(" "),e("p",[v._v("浏览器进程会通过"),e("code",[v._v("进程间通信IPC")]),v._v("将URL请求发送给网络进程，网络进程接受到URL请求后，会发起真正的URL请求进程")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("判断强缓存\n网络进程首先会查找浏览器本地是否存在强缓存，若本地存在缓存，并且缓存没有过期的话，则直接从浏览器缓存中读取资源返回给浏览器进程")])]),v._v(" "),e("li",[e("p",[v._v("DNS域名解析\n若本地不存在缓存或者缓存过期，则代表网络进程需要向服务器请求资源，请求之前，需要针对url地址进行"),e("code",[v._v("DNS域名解析")]),v._v("，DNS域名解析过程中，如果"),e("code",[v._v("DNS数据缓存服务")]),v._v("缓存过当前域名，则直接返回当前对应的IP地址和端口号，若不存在，则需要向dns发起请求，返回域名对应的IP地址和端口号；如果是"),e("code",[v._v("https协议")]),v._v("，则还需要建立 "),e("code",[v._v("TLS 连接")]),v._v("；如果没有端口号，http默认80，https默认443")])]),v._v(" "),e("li",[e("p",[v._v("建立tcp连接、构建请求信息、发送请求信息\nchome机制浏览器同一个域名下，最后可以建立6个tcp链接，超多这个数目，需要放入tcp队列中，处于排队等待的状态。\n网络进程拿到IP地址后，需要利用IP地址跟服务器建立TCP连接，通过三次握手，成功建立连接后，浏览器端会构建请求行、请求头、请求体等信息（"),e("code",[v._v("构建请求头")]),v._v("），并且把该域名下相关联的"),e("code",[v._v("cookie")]),v._v("等数据附加到请求头中，然后向服务器发送构建请求的信息("),e("code",[v._v("发送请求头")]),v._v(")\n"),e("code",[v._v("补充:")]),v._v("\nTCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输\n网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层\n底层通过物理网络传输给目的服务器主机\n目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层\n目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层\n响应数据顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程")])]),v._v(" "),e("li",[e("p",[v._v("服务器响应，网络进程解析响应头，响应行，解析响应内容，关闭连接\n服务器端在接受到请求头后，会根据请求内容生成具体的响应信息（响应行、响应头、响应体等信息），发送给网络进程。等网络进程，拿到具体的响应信息后，就开始具体的响应头内容解析了。\n响应完成后，关闭连接（四次挥手）")])]),v._v(" "),e("li",[e("p",[v._v("重定向、304缓存\n返回的是301、302，则浏览器需要重新重定向到其他的URL地址，网络进程从Location自动中读取地址，重复url请求\n返回的是304，则浏览器会读取本地的缓存资源，返回给浏览器进程\n返回的是200，检查"),e("code",[v._v("响应数据类型处理")])])]),v._v(" "),e("li",[e("p",[v._v("响应数据类型处理\n网络进程子啊获取到响应信息后，通过响应头中的"),e("code",[v._v("content-type")]),v._v("字段，区分当前内容的类型，常规的返回的"),e("code",[v._v("text/html")]),v._v("为html格式，通知渲染进程准备进行渲染\n如果"),e("code",[v._v("application/octet-stream")]),v._v("则表示内容为字节流类型，说明这是个下载文件，则将交给下载管理器来下载当前资源，同时浏览器当前的导航栏关闭")])]),v._v(" "),e("li",[e("p",[v._v("渲染进程\n判断当前地址是否存在同一个站点，若存在，复用已经存在的渲染进程，反之，开启新的渲染进程")])]),v._v(" "),e("li",[e("p",[v._v("提交文档\n浏览器进程在收到网络进程接收到响应内容时，浏览器进程向渲染进程发起一个"),e("code",[v._v("提交文档")]),v._v("请求，渲染进程在收到该请求后，会跟网络进程建立一个"),e("code",[v._v("传输数据的管道")]),v._v(",当渲染进程接受数据完毕后，向浏览器进程发起"),e("code",[v._v("确认提交")]),v._v("的信息\n浏览器收到"),e("code",[v._v("确认提交")]),v._v("信息后，会更新相应的浏览器安全，URL地址栏，前进后退的历史信息状态，更新web页面（"),e("code",[v._v("此时的web页面是空白页")]),v._v("）\n渲染进程开始正式进入渲染流程")])])]),v._v(" "),e("h2",{attrs:{id:"渲染进程开始正式进入渲染流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程开始正式进入渲染流程"}},[v._v("#")]),v._v(" 渲染进程开始正式进入渲染流程")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("构建dom树\n渲染进程需要将 HTML 构建成浏览器所能理解的浏览器结构 dom树 结构")])]),v._v(" "),e("li",[e("p",[v._v("css样式计算\n渲染进程通过css样式表，\n将css转换成浏览器可以理解的styleSheets对象，\n并且需要将样式表的属性值进行标准化处理，\n并且计算节点的样式（根据css继承和层叠样式规则来算出dom每个节点的样式）")])]),v._v(" "),e("li",[e("p",[v._v("创建布局树、布局计算\n创建布局树：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中，不可见节点忽略\n布局计算：将对应的节点的styleSheets对象合并，计算出展示节点的具体样式\n通过布局计算，就可以计算出节点具体的布局信息了")])]),v._v(" "),e("li",[e("p",[v._v("分层（构建图层树）\n在布局树中的节点，渲染引擎针对符合分层条件（"),e("code",[v._v("层叠上下文或内容溢出、需要裁剪的元素导致出现的滚动条")]),v._v("）的节点，建立独立的图层，并生成对应的图层树")])]),v._v(" "),e("li",[e("p",[v._v("图层绘制\n在图层树构建完成后，渲染引擎会针对每个图层进行 "),e("code",[v._v("图层绘制")]),v._v("，当图层绘制过程中，一个图层的绘制拆分成很多小的"),e("code",[v._v("绘制指令")]),v._v("，然后再把这些指令按照顺序组成一个"),e("code",[v._v("待绘制列表")])])]),v._v(" "),e("li",[e("p",[v._v("光栅化（栅格化）\n当"),e("code",[v._v("图层的绘制列表")]),v._v("准备好之后，主线程会把该绘制列表提交（commit）给"),e("code",[v._v("合成线程")]),v._v("\n合成线程会将"),e("code",[v._v("图层")]),v._v("划分成"),e("code",[v._v("图块tile")]),v._v("(256"),e("em",[v._v("256、521")]),v._v("512)，在栅格化线程池中，合成线程会优先获取viewport视图附近的图块生成位图\n栅格化的过程，会使用GPU加速位图的生成，生成的位图保存在GPU内存中")])]),v._v(" "),e("li",[e("p",[v._v("合成阶段（Draw  quad）显示\n当所有的图层都光栅化为位图后，合成线程会生成一个绘制图块的命令（Draw guad）发送给浏览器进程，\n浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上\n浏览器进程在接收到Draw guad命令后，从GPU内存中读取图片输出到显卡后缓冲区，显卡将后缓冲区内容交换至前缓冲区，由屏幕已60HZ的频率刷新显示图片")])]),v._v(" "),e("li",[e("p",[v._v("显示图像（Display）\n看下渲染引擎的图像是如何显示到显示器的，先来看下如下概念")])])]),v._v(" "),e("p",[v._v("帧、帧率：渲染流水线生成一张图片为一帧，每秒渲染帧数称为帧率，如果每秒帧率为60，则为60FPS，\n显卡：显卡的职责就是合成新的图像，并将图像保存在后缓冲区，显卡中维护了两块区域，前缓冲区和后缓冲区。\n前缓冲区：显示器都由固定的刷新频率，通常是60HZ，也就是每秒刷新60张图片，更新的图片都来自于显卡的前缓冲区，显示器固定每秒60次的读取速度读取前缓冲区的图像，并显示在显示器上。\n后缓冲区：一旦显卡把合成的图像保存到后缓冲区，后缓冲区和前缓冲区交换，当滚动或缩放时，渲染引擎通过渲染流水线产生图片并发送到显卡的后缓冲区，显示器刷出图像，显卡更新的频率和显示器刷新频率是一致的，但复杂场景，会出现显卡处理一张图片的速度变慢，造成视觉卡顿")]),v._v(" "),e("h2",{attrs:{id:"重绘repaint、重排reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重绘repaint、重排reflow"}},[v._v("#")]),v._v(" 重绘Repaint、重排Reflow")]),v._v(" "),e("h3",{attrs:{id:"引起重排-回流-的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引起重排-回流-的原因"}},[v._v("#")]),v._v(" 引起重排(回流)的原因")]),v._v(" "),e("p",[v._v("页面首次渲染\n浏览器窗口resize大小发生改变\n元素尺寸或位置发生改变\n元素内容变化（文字数量或图片大小等等）\n元素字体大小变化\n添加或者删除可见的DOM元素\n激活CSS伪类（例如：:hover）\n通过js设置style属性\n查询某些属性或调用某些方法")]),v._v(" "),e("h3",{attrs:{id:"引起重绘的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引起重绘的原因"}},[v._v("#")]),v._v(" 引起重绘的原因")]),v._v(" "),e("p",[v._v("修改节点的背景颜色，字体颜色，border-style等等")]),v._v(" "),e("h3",{attrs:{id:"如何减少-重绘repaint、重排reflow"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何减少-重绘repaint、重排reflow"}},[v._v("#")]),v._v(" 如何减少 重绘Repaint、重排Reflow")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("使用 class 操作样式，而不是频繁通过js来操作 style\n避免设置大量的style属性，因为通过设置style属性改变节点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性\n减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画\n一定要通过style修改，则 "),e("code",[v._v("合并样式修改")])])]),v._v(" "),e("li",[e("p",[v._v("避免使用 table 布局\n因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围")])]),v._v(" "),e("li",[e("p",[v._v("批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React\n操作DOM会很慢，最小化DOM访问次数，尽量缓存访问DOM的样式信息，避免过度触发回流")])]),v._v(" "),e("li",[e("p",[v._v("Debounce（防抖） window resize 事件")])]),v._v(" "),e("li",[e("p",[v._v("对 dom 属性的读写要分离")])]),v._v(" "),e("li",[e("p",[v._v("will-change: transform 做优化（硬件加速）")])]),v._v(" "),e("li",[e("p",[v._v("动画尽量使用在绝对定位 absolute或 固定定位 fixed 的元素上")])]),v._v(" "),e("li",[e("p",[v._v("减少不必要的 DOM 深度\n在 DOM 树中的一个级别进行更改可能会致使该树的所有级别（上至根节点，下至所修改节点的子级）都随之变化。这会导致花费更多的时间来执行重排。")])]),v._v(" "),e("li",[e("p",[v._v("避免使用不必要且复杂的 CSS 选择器（尤其是后代选择器）\n因为此类选择器需要耗用更多的 CPU 处理能力来执行选择器匹配。")])])]),v._v(" "),e("h3",{attrs:{id:"为什么操作-dom-慢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么操作-dom-慢"}},[v._v("#")]),v._v(" 为什么操作 DOM 慢")]),v._v(" "),e("p",[v._v("一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。")])])}),[],!1,null,null,null);_.default=a.exports}}]);