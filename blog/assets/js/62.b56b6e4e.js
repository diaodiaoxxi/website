(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{623:function(v,_,a){"use strict";a.r(_);var t=a(22),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"硬件加速"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#硬件加速"}},[v._v("#")]),v._v(" 硬件加速")]),v._v(" "),a("p",[a("code",[v._v("一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘和回流，提升性能")])]),v._v(" "),a("h2",{attrs:{id:"渲染图层、复合图层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染图层、复合图层"}},[v._v("#")]),v._v(" 渲染图层、复合图层")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("渲染图层RenderLayer")]),v._v(" "),a("ul",[a("li",[v._v("是页面普通的文档流")]),v._v(" "),a("li",[v._v("通过绝对定位，相对定位，浮动定位脱离文档流（生成相对应的渲染图层），但它仍然属于默认复合层(根层叠上下文)，共用同一个绘图上下文对象（GraphicsContext）")])])]),v._v(" "),a("li",[a("p",[v._v("复合图层GraphicsLayer（图形层、合成层）")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("单独分配系统资源")]),v._v(",每个复合图层都有一个独立的GraphicsContext")]),v._v(" "),a("li",[v._v("当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘")])])]),v._v(" "),a("li",[a("p",[v._v("只有 GraphicsLayer 是作为纹理(texture)（位图）上传给GPU的。")])]),v._v(" "),a("li",[a("p",[v._v("纹理：可以把它想象成一个从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的"),a("code",[v._v("位图图像")]),v._v("(bitmapimage)")])])]),v._v(" "),a("h2",{attrs:{id:"开启硬件加速"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开启硬件加速"}},[v._v("#")]),v._v(" 开启硬件加速")]),v._v(" "),a("ul",[a("li",[v._v("3D转换：translate3d，translateZ依此类推；")]),v._v(" "),a("li",[a("code",[v._v("<video>，<canvas>和<iframe>")]),v._v("元件;")]),v._v(" "),a("li",[v._v("transform和opacity经由Element.animate();")]),v._v(" "),a("li",[v._v("transform和opacity经由СSS过渡和动画;")]),v._v(" "),a("li",[v._v("有合成层后代同时本身 fixed 定位")]),v._v(" "),a("li",[v._v("will-change;")]),v._v(" "),a("li",[v._v("拥有加速 CSS 过滤器的元素filter;")]),v._v(" "),a("li",[v._v("元素包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)，而这个兄弟元素的z-index比较小，小于当前元素，那么这个元素（不管是不是应用了硬件加速样式）也会被放到复合层中（注意：容易引起层爆炸）")]),v._v(" "),a("li",[v._v("元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)")])]),v._v(" "),a("h2",{attrs:{id:"合成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成"}},[v._v("#")]),v._v(" 合成")]),v._v(" "),a("p",[v._v("合成是一种将页面拆分成不同的 layers，分别将他们"),a("code",[v._v("栅格化")]),v._v("(生成位图)，然后在一个独立的线程——合成器线程里再合成为一个页面。一旦页面滚动，合成器就会将栅格化好的层合成一个新的帧")]),v._v(" "),a("h2",{attrs:{id:"复合图层的作用？（为什么硬件加速会使页面流畅）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复合图层的作用？（为什么硬件加速会使页面流畅）"}},[v._v("#")]),v._v(" 复合图层的作用？（为什么硬件加速会使页面流畅）")]),v._v(" "),a("p",[v._v("如果你对一个元素应用动画（60fps），主线程需要一帧一帧地渲染，因为动画和 JS 都是在主线程上运行的，如果此时有 JS 占用了过长的时间，就会导致帧渲染不及时，从而动画掉帧。")]),v._v(" "),a("ul",[a("li",[v._v("合成层的位图，会交给GPU来合成，比CPU处理的更快，且不容易阻塞主线程的执行")]),v._v(" "),a("li",[v._v("CPU与GPU并行行，以同时运行以创建高效的图形管道")]),v._v(" "),a("li",[v._v("当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层")]),v._v(" "),a("li",[v._v("对于 transform 和 opacity 效果，不会触发 layout 、layer和 paint,直接进入合成线程处理")])]),v._v(" "),a("h2",{attrs:{id:"注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意点"}},[v._v("#")]),v._v(" 注意点")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("提升到合成层后合成层的位图会交GPU处理，但请注意，仅仅只是合成的处理需要用到GPU，生成合成层的位图处理是需要CPU。")])]),v._v(" "),a("li",[a("p",[v._v("当需要 repaint 的时候可以只 repaint 本身，不影响其他层，但是 paint 之前还有 style(样式计算)， layout（布局） 渲染过程，那就意味着即使合成层只是 repaint 了自身，但 style 和 layout 本身就很占用时间。所以要合理控制合层层的层数，不能一味的开启元素的硬件加速，会影响性能")])]),v._v(" "),a("li",[a("p",[v._v("通过transform和opacity创建的复合图层不会引发 layout 和paint，其他的属性暂未确定，因为这两个没有发生形变和rgb变化")])])]),v._v(" "),a("h2",{attrs:{id:"性能优化点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化点"}},[v._v("#")]),v._v(" 性能优化点")]),v._v(" "),a("ul",[a("li",[v._v("提升动画效果的元素 合成层的好处是"),a("code",[v._v("不会影响到其他元素的绘制")]),v._v("，设置will-change")]),v._v(" "),a("li",[v._v("使用 transform 或者 opacity 来实现动画效果， 这样只需要做合成层的合并就好了")]),v._v(" "),a("li",[v._v("减少绘制区域 对于不需要重新绘制的区域应尽量避免绘制")])]),v._v(" "),a("h2",{attrs:{id:"复合图层的使用注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复合图层的使用注意事项"}},[v._v("#")]),v._v(" 复合图层的使用注意事项")]),v._v(" "),a("ul",[a("li",[v._v("尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡")]),v._v(" "),a("li",[v._v("层爆炸，虽然浏览器有层压缩的机制，但是在使用上也有限制，使用不当，就容易出现层爆炸的问题")]),v._v(" "),a("li",[v._v("复合图层会占用系统 RAM 与 GPU(在移动设备上尤其有限)的内存，并且拥有大量的层会因为记录哪些是可见的而引入额外的开销。许多层还会因为过大与许多内容重叠而导致“过度绘制(overdraw)”的情况发生，从而增加栅格化的时间")])]),v._v(" "),a("h2",{attrs:{id:"如何理解-gpu-硬件加速？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-gpu-硬件加速？"}},[v._v("#")]),v._v(" 如何理解 GPU 硬件加速？")]),v._v(" "),a("p",[v._v("GPU硬件加速：主要是利用GPU提供一些特定的功能，使GPU为CPU来分担一些任务")]),v._v(" "),a("h3",{attrs:{id:"以动画效果为例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#以动画效果为例"}},[v._v("#")]),v._v(" 以动画效果为例")]),v._v(" "),a("p",[v._v("旧软件路径 渲染方式(默认)：")]),v._v(" "),a("ol",[a("li",[v._v("如果不在独立的渲染图层，动画效果会造成页面的回流重绘")]),v._v(" "),a("li",[v._v("比如设置在了position:absolute;绝对定位下，虽然当前元素脱离了普通文档流，但是元素还是在 "),a("code",[v._v("默认的复合图层中")]),v._v(" ，虽然动画不会造成页面的回流重绘，但是还是需要进行 图层绘制，即需要对动画的每一帧（包含其他元素图层的绘制），在进行合成操作，比较耗时")])]),v._v(" "),a("p",[v._v("硬件加速路径 渲染方式：")]),v._v(" "),a("ul",[a("li",[v._v("获取 DOM 并将其分割为多个层")]),v._v(" "),a("li",[v._v("将每个层独立的绘制进位图中")]),v._v(" "),a("li",[v._v("将层作为纹理上传至 GPU")]),v._v(" "),a("li",[v._v("复合多个层来生成最终的屏幕图像")])]),v._v(" "),a("ol",[a("li",[v._v("会将开启 硬件加速的的元素提升为 复合图层，脱离于普通文档流。")]),v._v(" "),a("li",[v._v("将复合图层作为纹理上传至 GPU，并且存储起来，然后之后浏览器只告诉GPU去转换指定的纹理（位图）来实现dom元素的动画更新，其他未改变的复合图层的纹理，可以从缓存中复用，这就叫做"),a("code",[v._v("GPU合成")])])]),v._v(" "),a("p",[v._v("缺点：")]),v._v(" "),a("ul",[a("li",[v._v("内存。如果GPU加载了大量的纹理，那么很容易就会发生内容问题，这一点在移动端浏览器上尤为明显，所以，一定要牢记不要让页面的每个元素都使用硬件加速。")]),v._v(" "),a("li",[v._v("使用GPU渲染会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制。即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊")])])])}),[],!1,null,null,null);_.default=i.exports}}]);