(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{514:function(t,v,_){t.exports=_.p+"assets/img/http2.86cdf01a.png"},515:function(t,v,_){t.exports=_.p+"assets/img/https.77c852ff.png"},612:function(t,v,_){"use strict";_.r(v);var a=_(22),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),a("h2",{attrs:{id:"http0-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http0-9"}},[t._v("#")]),t._v(" http0.9")]),t._v(" "),a("p",[t._v("1991年提出的，支持简单的纯文本html页面请求")]),t._v(" "),a("ul",[a("li",[t._v("只有请求行，没有请求头、请求体")]),t._v(" "),a("li",[t._v("服务器也没有响应头信息")]),t._v(" "),a("li",[t._v("返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件(html,没有js,css等文件的加载)")])]),t._v(" "),a("h2",{attrs:{id:"http1-0-短链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-0-短链接"}},[t._v("#")]),t._v(" http1.0 短链接")]),t._v(" "),a("p",[t._v("背景：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("accept"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" text"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("html "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 希望请求文件的类型")]),t._v("\naccept"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("encoding"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" gzip"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" deflate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" br "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可接受的数据压缩发哪个是你")]),t._v("\naccept"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Charset"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ISO")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8859")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("utf"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 编码方式")]),t._v("\naccept"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("language"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" zh"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("zh\n\n")])])]),a("ul",[a("li",[t._v("由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。 accept")]),t._v(" "),a("li",[t._v("单个文件的数据量也变得越来越大，为了减轻传输性能，以浏览器需要知道服务器压缩的方法。 accept-encoding: gzip, deflate, br")]),t._v(" "),a("li",[t._v("由于万维网的全球性，支持不同国家的语言。 accept-language")])]),t._v(" "),a("p",[t._v("总结：")]),t._v(" "),a("ul",[a("li",[t._v("引入了请求头、响应头，以key-value形式保存，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息")]),t._v(" "),a("li",[t._v("有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了"),a("code",[t._v("状态码")]),t._v("。状态码是通过响应行的方式来通知浏览器的")]),t._v(" "),a("li",[t._v("为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。")]),t._v(" "),a("li",[t._v("服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了"),a("code",[t._v("用户代理")]),t._v("的字段。")])]),t._v(" "),a("p",[t._v("特点：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("短链接：常规http请求，一个TCP连接中同时只能由一个http请求")])]),t._v(" "),a("li",[a("p",[t._v("缓存处理："),a("code",[t._v("If-Modified-Since")]),t._v(" "),a("code",[t._v("Expires")]),t._v("作为缓存判断标准")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("线头阻塞")]),t._v(" head of line blocking")])])]),t._v(" "),a("h2",{attrs:{id:"http1-1-长连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-长连接"}},[t._v("#")]),t._v(" http1.1 长连接")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("支持持久化链接")]),t._v(" "),a("ul",[a("li",[t._v("contention: keep-alive 实现了长连接 PersistentConnection，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点；")]),t._v(" "),a("li",[t._v("特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。")]),t._v(" "),a("li",[t._v("contention: close 关闭持久链接，"),a("code",[t._v("目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接")])])])]),t._v(" "),a("li",[a("p",[t._v("支持http管道")]),t._v(" "),a("ul",[a("li",[t._v("HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中，而在发送过程中不需要等待服务器对前一个请求的响应")]),t._v(" "),a("li",[t._v("只不过，客户端还是需要按照http发送请求的顺序来接受响应。即客户端可以并行，服务端串行")]),t._v(" "),a("li",[t._v("由于http请求的时间是不确定的，可能会造成后续http请求阻塞，就可能会造成 "),a("code",[t._v("队头阻塞")])])])]),t._v(" "),a("li",[a("p",[t._v("提供虚拟主机的支持")]),t._v(" "),a("ul",[a("li",[t._v("在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。")]),t._v(" "),a("li",[t._v("HTTP/1.1 的请求头中增加了 "),a("code",[t._v("Host")]),t._v(" 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。")])])]),t._v(" "),a("li",[a("p",[t._v("对动态生成的内容提供了完美支持")]),t._v(" "),a("ul",[a("li",[t._v("HTTP/1.0 通过 "),a("code",[t._v("content-type")]),t._v(" 可以提前判断字节数")]),t._v(" "),a("li",[t._v("HTTP/1.1 通过引入 "),a("code",[t._v("Chunk transfer")]),t._v(" 机制（"),a("code",[t._v("分块传输")]),t._v("）来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持")])])]),t._v(" "),a("li",[a("p",[t._v("客户端 Cookie、安全机制")])]),t._v(" "),a("li",[a("p",[t._v("缓存处理："),a("code",[t._v("If-Not-Match/Etag")]),t._v("，"),a("code",[t._v("cache-control")])])])]),t._v(" "),a("h3",{attrs:{id:"http-1-1-的主要问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-的主要问题"}},[t._v("#")]),t._v(" HTTP/1.1 的主要问题")]),t._v(" "),a("p",[t._v("对带宽的利用率却并不理想，带宽是指每秒最大能发送或者接收的字节数")]),t._v(" "),a("ul",[a("li",[t._v("TCP 的慢启动")]),t._v(" "),a("li",[t._v("同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽")]),t._v(" "),a("li",[t._v("HTTP/1.1 队头阻塞的问题")])]),t._v(" "),a("h2",{attrs:{id:"http2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" http2")]),t._v(" "),a("p",[t._v("在http/2提出之前，chrome在2012年提出了 "),a("code",[t._v("SPDY")]),t._v("方法，针对http1.1，推出多路复用，设置请求头优先级，header压缩，server推送，server暗示")]),t._v(" "),a("p",[a("code",[t._v("HTTP/2和SPDY不同的地方在于，它是业界标准，而SPDY是chrome自家的孩子，马虎不得，一言一行都得考虑明星效应")])]),t._v(" "),a("p",[t._v("背景：HTTP/2 的思路就是，实现一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要"),a("code",[t._v("一次慢启动")]),t._v("，"),a("code",[t._v("同时也避免了多个 TCP 连接竞争带宽所带来的问题")]),t._v("，同时"),a("code",[t._v("实现资源的并行请求")]),t._v("，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器，这样就解决了http1.1队头阻塞的问题")]),t._v(" "),a("h3",{attrs:{id:"多路复用机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多路复用机制"}},[t._v("#")]),t._v(" 多路复用机制")]),t._v(" "),a("p",[a("img",{attrs:{src:_(514),alt:"avatar"}})]),t._v(" "),a("ol",[a("li",[a("p",[t._v("流程")]),t._v(" "),a("p",[a("code",[t._v("通过引入二进制分帧层，就实现了 HTTP 的多路复用技术")]),t._v("，二进制帧为HTTP/2的“基本单位”")]),t._v(" "),a("p",[t._v("把HTTP/1.x每个请求都当作一个“流”，那么请求化成多个流，请求响应数据切成多个帧，不同流中的帧交错地发送给对方，这就是HTTP/2中的多路复用")]),t._v(" "),a("ul",[a("li",[t._v("首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。")]),t._v(" "),a("li",[t._v("这些数据经过"),a("code",[t._v("二进制分帧层")]),t._v("处理之后，会被转换为一个个带有请求 "),a("code",[t._v("ID 编号")]),t._v("的帧，通过协议栈将这些帧发送给服务器。")]),t._v(" "),a("li",[t._v("服务器接收到所有帧之后，会将所有"),a("code",[t._v("相同 ID 的帧合并为一条完整的请求信息")]),t._v("。")]),t._v(" "),a("li",[t._v("然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至"),a("code",[t._v("二进制分帧层")]),t._v("。")]),t._v(" "),a("li",[t._v("同样，"),a("code",[t._v("二进制分帧层")]),t._v("会将这些响应数据"),a("code",[t._v("转换")]),t._v("为一个个带有请求 "),a("code",[t._v("ID 编号")]),t._v("的帧，经过协议栈发送给浏览器。")]),t._v(" "),a("li",[t._v("浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求；根据相同ID编号的帧组装成一个完整的数据")])])]),t._v(" "),a("li",[a("p",[t._v("其他特性")]),t._v(" "),a("ul",[a("li",[t._v("设置请求头的顺序。服务器端可以根据页面的优先级，设置优先返回那些关键的资源")]),t._v(" "),a("li",[t._v("服务器推送(server push)。针对首屏优化有比较好的提升。比如当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。")]),t._v(" "),a("li",[t._v("头部压缩。重点正对post请求体发送，针对请求头，响应头做压缩的处理")])])]),t._v(" "),a("li",[a("p",[t._v("缺点")]),t._v(" "),a("ul",[a("li",[t._v("tcp协议的数据流传输过程中的 "),a("code",[t._v("队头阻塞")]),t._v("。 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会"),a("code",[t._v("阻塞该 TCP 连接中的所有请求")]),t._v("，所以随着"),a("code",[t._v("丢包率")]),t._v("的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。")]),t._v(" "),a("li",[t._v("TCP 建立连接的延时")]),t._v(" "),a("li",[t._v("TCP 协议僵化")])])])]),t._v(" "),a("h2",{attrs:{id:"quic协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quic协议"}},[t._v("#")]),t._v(" QUIC协议")]),t._v(" "),a("p",[t._v("全新的协议，独立于http协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能")]),t._v(" "),a("ul",[a("li",[t._v("实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。")]),t._v(" "),a("li",[t._v("集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。")]),t._v(" "),a("li",[t._v("实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流")])]),t._v(" "),a("h2",{attrs:{id:"http优化思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http优化思路"}},[t._v("#")]),t._v(" http优化思路")]),t._v(" "),a("p",[t._v("影响一个 HTTP 网络请求的因素主要有两个："),a("code",[t._v("带宽")]),t._v("和"),a("code",[t._v("延迟")]),t._v("。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。")])]),t._v(" "),a("li",[a("p",[t._v("延迟：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。")]),t._v(" "),a("li",[t._v("DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。")]),t._v(" "),a("li",[t._v("建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。")])])])]),t._v(" "),a("h2",{attrs:{id:"http-1-1优化机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1优化机制"}},[t._v("#")]),t._v(" HTTP/1.1优化机制")]),t._v(" "),a("p",[t._v("增加了持久连接；\n浏览器为每个域名最多同时维护 6 个 TCP 持久连接；\n使用 CDN 的实现域名分片机制。")]),t._v(" "),a("ol",[a("li",[t._v("Spriting（图片合并）：但有时候只需要其中一张小图，就会浪费流量")]),t._v(" "),a("li",[t._v("Inlining（内容内嵌）：比如把图片转化为base64编码后内嵌到总文件中，问题同上")]),t._v(" "),a("li",[t._v("Concatenation（文件合并）：粒度变大，一个小的js代码改动会导致整个js文件被下载")]),t._v(" "),a("li",[t._v("Domain Sharding（域名分片）：浏览器或者客户端是根据domain（域名）来建立连接，多建立几个sub domain（子域名），那么同时可以建立的http请求就会更多，连接数变多之后，受限制的请求就不需要等待前面的请求完成才能发出了；只有在请求数非常之多的场景下才有明显的效果，移动端建议不要使用")])]),t._v(" "),a("h2",{attrs:{id:"https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" https")]),t._v(" "),a("p",[t._v("HTTPS 保证了"),a("code",[t._v("传输安全")]),t._v("，防止传输过程被"),a("code",[t._v("监听")]),t._v("、防止"),a("code",[t._v("数据被窃取")]),t._v("，可以确认网站的真实性。")]),t._v(" "),a("p",[t._v("在http协议栈中添加了 一个 安全层（SSL/TLS）")]),t._v(" "),a("p",[t._v("HTTPS 使用了对称和非对称的混合加密方式，这解决了数据传输安全的问题；")]),t._v(" "),a("p",[t._v("HTTPS 引入了中间机构 CA，CA 通过给服务器颁发数字证书，解决了浏览器对服务器的信任问题")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("数据的安全传输")]),t._v(" "),a("ul",[a("li",[t._v("采用的是混合加密的机制，")]),t._v(" "),a("li",[a("code",[t._v("对称加密的方式加密传输数据")]),t._v(" "),a("ul",[a("li",[t._v("通过 client random + server random + pre-master 加密生成 master-secert(会话公钥)")])])]),t._v(" "),a("li",[a("code",[t._v("非对称加密的方式来传输密钥")]),t._v(" "),a("ul",[a("li",[t._v("pre-master非对称加密传输的")]),t._v(" "),a("li",[t._v("浏览器端 通过 公钥 对 pre-master  加密 （通过client random + server random +  公钥解密）")]),t._v(" "),a("li",[t._v("服务端 通过 私钥 对 pre-master 解密\n-采用 "),a("code",[t._v("master-secert（会话秘钥） 加密数据传输")]),t._v(" 这种方式虽然能保证"),a("code",[t._v("数据的安全传输")]),t._v("，但是依然没办法证明服务器是可靠的")])])])])]),t._v(" "),a("li",[a("p",[t._v("验证身份: 防止”中间人“攻击，同时可以为网站提供身份证明。")]),t._v(" "),a("ul",[a("li",[t._v("入了数字证书，"),a("code",[t._v("数字证书是由 CA 签名过的")]),t._v("，所以浏览器能够验证该证书的可靠性")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(515),alt:"avatar"}})]),t._v(" "),a("h2",{attrs:{id:"https-三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https-三次握手"}},[t._v("#")]),t._v(" https 三次握手")]),t._v(" "),a("ol",[a("li",[t._v("Client发送 random1 + 加密算法列表 到 Server")]),t._v(" "),a("li",[t._v("Server接受到信息后，返回 random2 + 返回确认后的加密算法 + 服务器的数字证书 + 确认的密码套件列表")]),t._v(" "),a("li",[t._v("Client验证证书的有效性后，发送 由 random1+random2 生成的 pre-random 通过服务器的公钥加密 发送到 服务器")]),t._v(" "),a("li",[t._v("Server接收到per-master， random1+random2+per-master（解密后）生成 master-secret（会话秘钥），然后发送预定成功，服务器握手结束通知，表示服务器的握手阶段已经结束")]),t._v(" "),a("li",[t._v("Client收到生成同样的master-secert，对称加密秘钥传输完毕")])]),t._v(" "),a("h2",{attrs:{id:"中间人攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中间人攻击"}},[t._v("#")]),t._v(" 中间人攻击")]),t._v(" "),a("p",[t._v("中间人 (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制. "),a("code",[t._v("在中间人攻击中, 攻击者可以拦截通讯双方的通话并插入新的内容。")])]),t._v(" "),a("p",[t._v("一般的过程如下：")]),t._v(" "),a("ol",[a("li",[t._v("客户端发送请求到服务端，请求被中间人截获")]),t._v(" "),a("li",[t._v("服务器向客户端发送公钥")]),t._v(" "),a("li",[t._v("中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端")]),t._v(" "),a("li",[t._v("客户端收到伪造的公钥后，生成加密hash值发给服务器")]),t._v(" "),a("li",[t._v("中间人获得加密hash值，用自己的私钥解密获得真秘钥,同时生成假的加密hash值，发给服务器")]),t._v(" "),a("li",[t._v("务器用私钥解密获得假密钥,然后加密数据传输给客户端")])])])}),[],!1,null,null,null);v.default=e.exports}}]);