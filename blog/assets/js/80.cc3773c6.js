(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{604:function(e,v,r){"use strict";r.r(v);var t=r(22),_=Object(t.a)({},(function(){var e=this,v=e.$createElement,r=e._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue3-0"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0"}},[e._v("#")]),e._v(" Vue3.0")]),e._v(" "),r("h2",{attrs:{id:"vue3-0特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0特性"}},[e._v("#")]),e._v(" Vue3.0特性")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("性能")]),e._v(" "),r("ul",[r("li",[e._v("双向响应原理由"),r("code",[e._v("Object.defineProperty")]),e._v("改为基于ES6的"),r("code",[e._v("Proxy")]),e._v("，使其颗粒度更大，速度更快，且消除了之前存在的警告；")]),e._v(" "),r("li",[e._v("重构vdom，优化vdom性能")]),e._v(" "),r("li",[e._v("针对模板编译进行了优化"),r("code",[e._v("diff算法优化、静态提升、事件监听缓存、SSR优化")])]),e._v(" "),r("li",[e._v("更加高效的组件初始化（生命周期，setup）")])])]),e._v(" "),r("li",[r("p",[e._v("Tree-Shaking(剪枝) 的支持")]),e._v(" "),r("ul",[r("li",[e._v("把不需要的东西给修剪掉，使 Vue3 的体积更小。")]),e._v(" "),r("li",[r("code",[e._v("按需引入")]),e._v("需要的模块才会打入到包里，优化后的 Vue3.0 的打包体积只有原来的一半")])])]),e._v(" "),r("li",[r("p",[e._v("Fragments")]),e._v(" "),r("ul",[r("li",[e._v("不再限制 template 只有一个根节点。")])])]),e._v(" "),r("li",[r("p",[e._v("更小")])]),e._v(" "),r("li",[r("p",[e._v("更快")])]),e._v(" "),r("li",[r("p",[e._v("TypeScript支持")])]),e._v(" "),r("li",[r("p",[e._v("API设计一致性")])]),e._v(" "),r("li",[r("p",[e._v("提高自身可维护性")])]),e._v(" "),r("li",[r("p",[e._v("开放更多底层功能")])])]),e._v(" "),r("h2",{attrs:{id:"说说vue2-0和vue3-0有什么区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#说说vue2-0和vue3-0有什么区别"}},[e._v("#")]),e._v(" 说说Vue2.0和Vue3.0有什么区别")]),e._v(" "),r("h2",{attrs:{id:"proxy-vs-object-defineproperty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-vs-object-defineproperty"}},[e._v("#")]),e._v(" Proxy vs Object.defineProperty")]),e._v(" "),r("h3",{attrs:{id:"proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),r("ul",[r("li",[e._v("创建一个对象的代理，实现基本操作的数据拦截和自定义（比如属性的查找、赋值、枚举、函数调用等等）")]),e._v(" "),r("li",[e._v("用于修改某些操作的默认行为, "),r("code",[e._v("可以理解为重新定义当前操作的意义")]),e._v(";\n也可以理解为在目标对象之前架设一层拦截,外部所有的访问都必须先通过这层拦截,因此提供了一种机制,可以对外部的访问进行过滤和修改")])]),e._v(" "),r("h3",{attrs:{id:"proxy作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy作用"}},[e._v("#")]),e._v(" Proxy作用")]),e._v(" "),r("ul",[r("li",[e._v("数据的拦截 javascript中真正的私有变量/拦截has...in...操作/给出提示信息或是阻止特定操作")]),e._v(" "),r("li",[e._v("数据的校验")]),e._v(" "),r("li",[e._v("进行记录对象属性的访问（类似埋点）")]),e._v(" "),r("li",[e._v("普通函数与构造函数的兼容（class类方法直接调用会报错，可针对该方法直接引用，内部创建new 生成对象）")]),e._v(" "),r("li",[e._v("深层取值判断（比如优化：undefined.xxx控制台会报错）")])]),e._v(" "),r("h3",{attrs:{id:"vue3-0-proxy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-proxy"}},[e._v("#")]),e._v(" vue3.0 Proxy")]),e._v(" "),r("ul",[r("li",[e._v("劫持方式：代理整个对象，只需做一层代理，就可以做到监听同一层结构下的所有属性变化，包括新增属性、删除属性")]),e._v(" "),r("li",[e._v("本质：本质上元编程，非破坏性数据劫持，在原对象的基础上进行了功能的衍生，而不破坏原对象。符合松耦合高内聚的设计理念")])]),e._v(" "),r("h3",{attrs:{id:"vue2-0-object-defineproperty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue2-0-object-defineproperty"}},[e._v("#")]),e._v(" vue2.0 Object.defineProperty")]),e._v(" "),r("ul",[r("li",[e._v("劫持方式：只能劫持对象的属性，不能直接代理对象")]),e._v(" "),r("li",[e._v("流程：通过发布-订阅者模式，针对对象属性get进行依赖收集，set变化时通知订阅者更新")]),e._v(" "),r("li",[e._v("存在的问题：虽然 Object.defineProperty 通过为属性设置 getter/setter 能够完成数据的响应式，但是它并不算是实现数据的响应式的完美方案，某些情况下需要对其进行修补或者hack")])]),e._v(" "),r("blockquote",[r("p",[e._v("无法检测到对象属性的新增和删除，只能通过"),r("code",[e._v("$set")]),e._v("方来实现新增属性的重新依赖收集\n无法检测到数组的变化；只能通过内部hack方法，调用"),r("code",[e._v("push、pop、reserve、sort、unshift、splice、slice")]),e._v("7个方法来实现数据的变化更新\nObject.defineProperty 无法一次性监听对象所有属性，如对象属性的子属性; 通过递归调用来实现子属性响应式")])]),e._v(" "),r("h3",{attrs:{id:"proxy-性能问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-性能问题"}},[e._v("#")]),e._v(" Proxy 性能问题")]),e._v(" "),r("ul",[r("li",[e._v("Proxy的性能比"),r("code",[e._v("Promise")]),e._v("还差")]),e._v(" "),r("li",[e._v("Proxy作为新标准，从长远来看，JS 引擎会继续优化 Proxy")])]),e._v(" "),r("h3",{attrs:{id:"proxy-兼容性差"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-兼容性差"}},[e._v("#")]),e._v(" Proxy 兼容性差")]),e._v(" "),r("ul",[r("li",[e._v("Vue 3.0 中放弃了对于IE的支持 (以为 Vue 3.0 中会对不兼容的浏览器进行向下兼容，但是经过查看资料和源码发现尤大压根没做兼容)")]),e._v(" "),r("li",[e._v("目前并没有一个完整支持 Proxy 所有拦截方法的 "),r("code",[e._v("Polyfill")]),e._v(" 方案，有一个 google 编写的 proxy-polyfill 也只支持了 get/set/apply/construct 四种拦截")])]),e._v(" "),r("h3",{attrs:{id:"decorator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#decorator"}},[e._v("#")]),e._v(" Decorator")]),e._v(" "),r("p",[e._v("ES7 中实现的 Decorator，相当于设计模式中的装饰器模式。\n如果简单地区分 Proxy 和 Decorator 的使用场景，可以概括为：Proxy 的核心作用是控制外界对被代理者内部的访问，Decorator 的核心作用是增强被装饰者的功能。")])])}),[],!1,null,null,null);v.default=_.exports}}]);