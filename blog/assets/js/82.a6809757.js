(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{602:function(e,a,v){"use strict";v.r(a);var l=v(22),_=Object(l.a)({},(function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"webpack"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[e._v("#")]),e._v(" webpack")]),e._v(" "),v("h2",{attrs:{id:"说一说loader和plugin的区别？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#说一说loader和plugin的区别？"}},[e._v("#")]),e._v(" 说一说Loader和Plugin的区别？")]),e._v(" "),v("ul",[v("li",[e._v("loader本质是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。")]),e._v(" "),v("li",[e._v("plugin本质是一个插件，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，"),v("code",[e._v("Plugin 可以监听这些事件")]),e._v("，在合适的时机通过 Webpack 提供的 API 改变输出结果。")]),e._v(" "),v("li",[e._v("loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个Object对象")]),e._v(" "),v("li",[e._v("plugin 是在 plugins单独配置，类型为数组。每一项都是一个plugin实例。通过构造函数生成")])]),e._v(" "),v("h2",{attrs:{id:"webpack构建流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack构建流程"}},[e._v("#")]),e._v(" Webpack构建流程")]),e._v(" "),v("ul",[v("li",[e._v("初始化。启动构建，通过配置文件和 shell 脚本读取和合并参数，加载 plugin，实例化compiler 对象")]),e._v(" "),v("li",[e._v("编译。从 entry 入口，针对 不同的 模块 串行调用对应的 Loader 去编译处理对应的文件内容。然后找到不同的模块所依赖的模块，递归进行编译处理")]),e._v(" "),v("li",[e._v("输出。编译好的 对应模块 组成 chuck，chuck再转换成文件，输出到文件系统")])]),e._v(" "),v("h2",{attrs:{id:"提高效率的插件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提高效率的插件"}},[e._v("#")]),e._v(" 提高效率的插件")]),e._v(" "),v("ul",[v("li",[e._v("webpack-dashboard：友好的输出打包信息")]),e._v(" "),v("li",[e._v("webpack-merge：提取公共的配置代码，减少重复的配置代码")]),e._v(" "),v("li",[e._v("size-plugin：监视资源体积的变化，以便于提早发现问题")]),e._v(" "),v("li",[e._v("hotmoduleReplacementPlugin：模块热替换")]),e._v(" "),v("li",[e._v("clean-webpack-plugin：打包清除插件")]),e._v(" "),v("li",[e._v("speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈")])]),e._v(" "),v("h2",{attrs:{id:"文件监听原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件监听原理"}},[e._v("#")]),e._v(" 文件监听原理")]),e._v(" "),v("p",[e._v("在发现源码发生变化时，自动重新构建出新的输出文件。")]),e._v(" "),v("p",[e._v("需要手动刷新浏览器")]),e._v(" "),v("ul",[v("li",[e._v("--watch")]),e._v(" "),v("li",[e._v("在配置 webpack.config.js 中设置 watch:true")])]),e._v(" "),v("h2",{attrs:{id:"webpack-的热更新原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的热更新原理"}},[e._v("#")]),e._v(" Webpack 的热更新原理")]),e._v(" "),v("p",[e._v("当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新")]),e._v(" "),v("ol",[v("li",[e._v("当修改了一个或多个文件；")]),e._v(" "),v("li",[e._v("文件系统接收更改并通知webpack；")]),e._v(" "),v("li",[e._v("webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；")]),e._v(" "),v("li",[e._v("HMR Server 使用webSocket通知HMR runtime 需要更新，会发送生成两个文件manifest.js和更新后的文件给浏览器，HMR运行时通过HTTP请求更新jsonp；")]),e._v(" "),v("li",[e._v("HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。")])]),e._v(" "),v("ul",[v("li",[e._v("webpack-server-dev 启动服务，包括提供静态资源的服务（express）、socket服务")]),e._v(" "),v("li",[e._v("当 socket server监听到 模块资源的改变时，会生成两个文件manifest.js和更新后的文件")]),e._v(" "),v("li",[e._v("socket server 会将其推动给 浏览器，浏览器会根据 HMR runtime机制加载文件，并且针对修改的模块进行更新")])]),e._v(" "),v("h2",{attrs:{id:"如何对bundle体积进行监控和分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何对bundle体积进行监控和分析"}},[e._v("#")]),e._v(" 如何对bundle体积进行监控和分析")]),e._v(" "),v("ul",[v("li",[e._v("VSCode 中有一个插件 Import Cost 可以帮助我们对引入模块的大小进行实时监测，")]),e._v(" "),v("li",[e._v("还可以使用 webpack-bundle-analyzer 生成 bundle 的模块组成图，显示所占体积。")]),e._v(" "),v("li",[e._v("bundlesize 工具包可以进行自动化资源体积监控")])]),e._v(" "),v("h2",{attrs:{id:"如何优化-webpack-的构建速度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何优化-webpack-的构建速度"}},[e._v("#")]),e._v(" 如何优化 Webpack 的构建速度")]),e._v(" "),v("ul",[v("li",[e._v("使用高版本的 webpack版本和node.js")]),e._v(" "),v("li",[e._v("压缩js、css文件 ：利用插件压缩")]),e._v(" "),v("li",[e._v("压缩图片")]),e._v(" "),v("li",[e._v("使用 DllPlugin插件，针对一些改动量不大比较稳定的代码，构建成静态资源文件,避免反复编译浪费时间")]),e._v(" "),v("li",[e._v("减少打包的作用域范围")]),e._v(" "),v("li",[e._v("充分利用一些loader或者插件缓存机制，提升二次打包的效率\n"),v("ul",[v("li",[e._v("babel-loader 开启缓存")]),e._v(" "),v("li",[e._v("terser-webpack-plugin 开启缓存")]),e._v(" "),v("li",[e._v("使用 cache-loader 或者 hard-source-webpack-plugin")])])]),e._v(" "),v("li",[e._v("提取页面公共资源，提取公共代码，基础包的分离")]),e._v(" "),v("li",[e._v("减少冗余代码")]),e._v(" "),v("li",[e._v("优化SourceMap")]),e._v(" "),v("li",[e._v("删除死代码（Tree Shaking）")]),e._v(" "),v("li",[e._v("动态 polifily")])])])}),[],!1,null,null,null);a.default=_.exports}}]);