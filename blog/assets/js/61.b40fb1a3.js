(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{624:function(e,t,a){"use strict";a.r(t);var o=a(22),v=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器缓存机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存机制"}},[e._v("#")]),e._v(" 浏览器缓存机制")]),e._v(" "),a("h2",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),a("p",[e._v("不访问服务器（http请求为发送，request头未发送出去）")]),e._v(" "),a("p",[e._v("request头部下面字段去做判断")]),e._v(" "),a("p",[e._v("Expires "),a("code",[e._v("http1.0产物")])]),e._v(" "),a("ul",[a("li",[e._v("Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。")]),e._v(" "),a("li",[e._v("Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效")]),e._v(" "),a("li",[e._v("eg: Expires: Wed, 11 May 2018 07:20:00 GMT")])]),e._v(" "),a("p",[e._v("Cache-Control "),a("code",[e._v("http1.1产物")]),e._v(" "),a("code",[e._v("优先级高于 Expires ,表示的是相对时间")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Cache-Control: max-age=315360000")])]),e._v(" "),a("li",[a("p",[e._v("Cache-Control: no-cache "),a("code",[e._v("不使用强缓存")]),e._v("\n强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control:no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。")])]),e._v(" "),a("li",[a("p",[e._v("Cache-Control: no-store 才是真正的不缓存数据到本地")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("200 form memory cache")]),e._v(": 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("200 from disk cache")]),e._v(": 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache")])])]),e._v(" "),a("p",[e._v("Pragma")]),e._v(" "),a("ul",[a("li",[e._v("Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，")]),e._v(" "),a("li",[e._v("在 3 个头部属性中的优先级最高")])]),e._v(" "),a("h2",{attrs:{id:"协商缓存（弱缓存）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存（弱缓存）"}},[e._v("#")]),e._v(" 协商缓存（弱缓存）")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("If-Not-Match/Etag "),a("code",[e._v("http1.1产物")]),e._v("\nif-not-match/Etag指的是一个唯一hash值，通过比较，")])]),e._v(" "),a("li",[a("p",[e._v("If-Modified-Since/Last-Modified "),a("code",[e._v("http1.0产物")]),e._v("\nheader中的if-modified-since最后修改时间、response头对应的last-modified字段的最后修改事件，相比较。若一致，则返回304，浏览器读取本地缓存")])])]),e._v(" "),a("blockquote",[a("p",[e._v("优先级上，Etag优先级高于Last-Modified\n性能上，Etag要逊于Last-Modified\nLast-Modified的最小时间精度是1S，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，Etag在每次修改的时候，都会进行更新\nEtag 又有"),a("code",[e._v("强弱校验")]),e._v('之分，如果 hash 码是以 "W/" 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存')])])])}),[],!1,null,null,null);t.default=v.exports}}]);