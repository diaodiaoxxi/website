(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{510:function(v,_,e){v.exports=e.p+"assets/img/queueStrategy.3cc95247.png"},626:function(v,_,e){"use strict";e.r(_);var t=e(22),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"消息任务队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息任务队列"}},[v._v("#")]),v._v(" 消息任务队列")]),v._v(" "),t("h2",{attrs:{id:"任务调度系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务调度系统"}},[v._v("#")]),v._v(" 任务调度系统")]),v._v(" "),t("p",[v._v("常见的任务：JavaScript 执行、DOM、CSS、样式布局、v8垃圾回收、用户的页面交互（鼠标点击、滚动、移动等）、浏览器resize、微任务（MutationObserver、Promise）、文件读写、WebSocket")]),v._v(" "),t("ul",[t("li",[v._v("第一次迭代：引入了 高优先级  任务队列")]),v._v(" "),t("li",[v._v("第二次迭代：针对不同的消息类型实现消息列表（优先级排序）\n"),t("ul",[t("li",[v._v("用户交互、合成页面、默认、空闲")])])]),v._v(" "),t("li",[v._v("第三次迭代：动态调度策略\n"),t("ul",[t("li",[v._v("基于不同的场景来动态调整消息队列的优先级")]),v._v(" "),t("li",[v._v("根据浏览器处于不同的场景，动态调整优先级的顺序\n"),t("img",{attrs:{src:e(510),alt:"avatar"}})])])]),v._v(" "),t("li",[v._v("任务饿死\n"),t("ul",[t("li",[v._v("Chromium 为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况")])])])]),v._v(" "),t("p",[t("code",[v._v("针对不同场景下的不同消息类型实现了不同的优先级排序的消息列表")]),v._v("，并且针对高优先级的消息长时间执行，中间会执行一次低优先级的任务，防止任务饿死的情况")]),v._v(" "),t("h2",{attrs:{id:"显示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#显示"}},[v._v("#")]),v._v(" 显示")]),v._v(" "),t("ul",[t("li",[v._v("浏览器生成图像，经过GPU,发送给 显卡的后缓冲区，")]),v._v(" "),t("li",[v._v("GPU 会将后缓冲区和前缓冲区互换位置，也就是前缓冲区变成了后缓冲区，后缓冲区变成了前缓冲区")]),v._v(" "),t("li",[v._v("显卡会 根据60HZ的 "),t("code",[v._v("刷新率")]),v._v(" 读取 前缓冲区")])]),v._v(" "),t("h3",{attrs:{id:"存在问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存在问题"}},[v._v("#")]),v._v(" 存在问题")]),v._v(" "),t("ul",[t("li",[v._v("渲染进程生成图片的 "),t("code",[v._v("帧速")]),v._v(" > 显卡的 "),t("code",[v._v("刷新率")]),v._v("，则会出现 "),t("code",[v._v("页面丢帧")]),v._v(" 的问题")]),v._v(" "),t("li",[v._v("渲染进程生成图片的 "),t("code",[v._v("帧速")]),v._v(" < 显卡的 "),t("code",[v._v("刷新率")]),v._v("，则会出现 "),t("code",[v._v("页面卡顿")]),v._v(" 的问题")]),v._v(" "),t("li",[v._v("渲染进程生成图片的 "),t("code",[v._v("帧速")]),v._v(" == 显卡的 "),t("code",[v._v("刷新率")]),v._v("，其 "),t("code",[v._v("浏览器生成帧的时钟周期")]),v._v("、"),t("code",[v._v("VSync时钟周期")]),v._v("也很难同步，则会出现 "),t("code",[v._v("页面不连贯")]),v._v(" 的问题")])]),v._v(" "),t("h3",{attrs:{id:"解决"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[v._v("#")]),v._v(" 解决")]),v._v(" "),t("p",[v._v("即："),t("code",[v._v("同步 VSync")])]),v._v(" "),t("p",[v._v("当显示器将一帧画面绘制完成后，并在准备读取下一帧之前，显示器会发出一个"),t("code",[v._v("垂直同步信号")]),v._v("（vertical synchronization）给 "),t("code",[v._v("GPU")]),v._v("，简称 VSync")]),v._v(" "),t("p",[v._v("具体地讲，当 GPU 接收到 VSync 信号后，会将 VSync 信号同步给浏览器进程，浏览器进程再将其同步到对应的渲染进程，渲染进程接收到 VSync 信号之后")]),v._v(" "),t("h2",{attrs:{id:"有了settimeout，为什么还要使用raf（requestanimationframe-）？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有了settimeout，为什么还要使用raf（requestanimationframe-）？"}},[v._v("#")]),v._v(" 有了setTimeOut，为什么还要使用rAF（requestAnimationFrame`）？")]),v._v(" "),t("p",[v._v("名词："),t("code",[v._v("浏览器生成帧的时钟周期")]),v._v("、"),t("code",[v._v("VSync时钟周期")])]),v._v(" "),t("ul",[t("li",[t("p",[t("code",[v._v("window.requestAnimationFrame")]),v._v("：讲  "),t("code",[v._v("浏览器生成帧的时钟周期")]),v._v(" "),t("code",[v._v("VSync时钟周期（显示器发GPU的垂直同步信号）")]),v._v("保持一致")])]),v._v(" "),t("li",[t("p",[t("code",[v._v("requestAnimationFrame")]),v._v("：回调任务会在每一帧的开始执行，相当于 显卡图像更新后，就会触发该函数的调用")])])]),v._v(" "),t("p",[v._v("CSS 动画是由渲染进程自动处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS 动画的高效率执行")]),v._v(" "),t("p",[v._v("但是 用JavaScript来实现动画的话，需要由用户控制的，如果采用 setTimeout 来触发动画每帧的绘制，（很难 保证"),t("code",[v._v("浏览器生成帧的时钟周期")]),v._v("、"),t("code",[v._v("VSync时钟周期")]),v._v("的一致性），那么其绘制时机是很难和 VSync 时钟保持一致的，所以 JavaScript 中又引入了 "),t("code",[v._v("window.requestAnimationFrame")]),v._v("，用来和 VSync 的时钟周期同步")]),v._v(" "),t("p",[v._v("举个例子：")]),v._v(" "),t("p",[v._v("width宽度有100到400的过渡动画")]),v._v(" "),t("ul",[t("li",[v._v("如果不添加任何操作，浏览器直接从100调到400，则没有过度的效果，图像值更新一次")]),v._v(" "),t("li",[v._v("如果通过 setTimeout 来实现过度的效果，很难实现 "),t("code",[v._v("VSync的时钟周期")]),v._v(" 和 "),t("code",[v._v("浏览器生成帧的时钟周期")]),v._v(" 保持一致，就可能出现 "),t("code",[v._v("动画不连贯")]),v._v(" 问题")]),v._v(" "),t("li",[v._v("使用 "),t("code",[v._v("window.requestAnimationFrame")]),v._v("，可以保证显卡在每次更新完一帧图像后，就触发回调，这样就能保证 "),t("code",[v._v("VSync的时钟周期")]),v._v(" 和 "),t("code",[v._v("浏览器生成帧的时钟周期")]),v._v(" 的一致，从而达到流畅的动画")])]),v._v(" "),t("h2",{attrs:{id:"微任务、宏任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#微任务、宏任务"}},[v._v("#")]),v._v(" 微任务、宏任务")]),v._v(" "),t("p",[v._v("V8 的宿主维护了消息队列，主线程不断从消息队列中取出任务，并依次执行，我们把消息队列中的任务称为宏任务")]),v._v(" "),t("p",[v._v("微任务是一个需要异步执行的函数，可以通过 Promise.reject 或者 Promise.resolve 来触发，执行时机是在当前调用 reject 或者 resolve 函数执行结束之后、当前宏任务结束之前")]),v._v(" "),t("p",[v._v("V8 在每个宏任务中维护了一个微任务队列")])])}),[],!1,null,null,null);_.default=a.exports}}]);