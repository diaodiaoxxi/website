(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{631:function(t,a,s){"use strict";s.r(a);var r=s(22),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"同源策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同源策略"}},[t._v("#")]),t._v(" 同源策略")]),t._v(" "),s("h2",{attrs:{id:"什么是同源策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是同源策略"}},[t._v("#")]),t._v(" 什么是同源策略")]),t._v(" "),s("p",[t._v("协议、域名和端口都相同，我们就称这两个 URL 同源")]),t._v(" "),s("h2",{attrs:{id:"同源策略的限制体现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#同源策略的限制体现"}},[t._v("#")]),t._v(" 同源策略的限制体现")]),t._v(" "),s("ul",[s("li",[t._v("DOM层面：限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作")]),t._v(" "),s("li",[t._v("数据层面：限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据")]),t._v(" "),s("li",[t._v("网络层面：限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点")])]),t._v(" "),s("h2",{attrs:{id:"安全和便利性的权衡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安全和便利性的权衡"}},[t._v("#")]),t._v(" 安全和便利性的权衡")]),t._v(" "),s("ol",[s("li",[t._v("页面中可以嵌入第三方资源\n"),s("ul",[s("li",[t._v("通过 link、script标签可以请求不在同源的资源")]),t._v(" "),s("li",[t._v("容易引起 "),s("code",[t._v("XSS")]),t._v(" 攻击。浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本")]),t._v(" "),s("li",[t._v("CSP("),s("code",[t._v("内容安全策略")]),t._v(") 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击")])])])]),t._v(" "),s("h2",{attrs:{id:"为什么会产生跨域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么会产生跨域"}},[t._v("#")]),t._v(" 为什么会产生跨域")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("原因：浏览器的同源策略")])]),t._v(" "),s("li",[s("p",[t._v("目的：为了保证用户信息的安全，防止恶意的网站窃取数据")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("同源策略限制")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("DOM层面：限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作")]),t._v(" "),s("li",[t._v("数据层面：限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据")]),t._v(" "),s("li",[t._v("网络层面：限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点")])])])]),t._v(" "),s("h2",{attrs:{id:"跨域解决方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨域解决方法"}},[t._v("#")]),t._v(" 跨域解决方法")]),t._v(" "),s("h3",{attrs:{id:"cors-跨域资源共享"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cors-跨域资源共享"}},[t._v("#")]),t._v(" CORS 跨域资源共享")]),t._v(" "),s("ul",[s("li",[t._v("简单请求")]),t._v(" "),s("li",[t._v("非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，叫做“预检”请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段\n一旦服务器通过了“预检”请求，在有效期内（max-age）以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段")])]),t._v(" "),s("h3",{attrs:{id:"jsonp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsonp"}},[t._v("#")]),t._v(" JSONP")]),t._v(" "),s("p",[t._v("JSONP只支持GET请求，CORS支持所有类型的HTTP请求")]),t._v(" "),s("h3",{attrs:{id:"ngnix反向代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ngnix反向代理"}},[t._v("#")]),t._v(" Ngnix反向代理")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("跨域是浏览器行为，不是服务器行为；服务器之间进行接口访问是不存在跨域行为的；")])]),t._v(" "),s("li",[s("p",[t._v("Ngnix反向代理用途：负载均衡，减轻服务器压力")])])]),t._v(" "),s("h3",{attrs:{id:"正向代理-vs-反向代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正向代理-vs-反向代理"}},[t._v("#")]),t._v(" 正向代理 vs 反向代理")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("正向代理隐藏了真实的客户端。")])]),t._v(" "),s("li",[s("p",[t._v("反向代理隐藏了真实的服务器.")])]),t._v(" "),s("li",[s("p",[t._v("正向代理：知道真正的请求地址(eg：域名+/api/xxx)，在向这个地址发送请求的时候，被代理服务器拦截，然后帮你去请求这个地址，最后把请求结果从真实服务器拿回来，再返回给你；")])]),t._v(" "),s("li",[s("p",[t._v("反向代理：不知道真正的请求地址，知道一个假的，在你请求这个假地址（这个假地址就是在代理配置的，当然也把正确的地址配置进去，通常是在服务端配置这个代理服务器，所以说这个真实地址对客户端是透明的）的时候，被代理服务器拦截，然后步骤跟上面一样；")])]),t._v(" "),s("li",[s("p",[t._v("vue webpack proxyTable配置代理即为 正向代理")])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在这个vue页面中，我开的项目端口是http://127.0.0.1:8070，而我请求的接口地址是http://127.0.0.1:2019/student，")]),t._v("\nproxyTable"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/api'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     target"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'http://127.0.0.1:2019'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这里是真正的接口,写到端口就行，不要把资源也带上去，比如/student")]),t._v("\n     changeOrigin"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n     pathRewrite"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n       "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'^/api'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这个的作用是当你配置了上面那个接口别名之后，你后面的页面请求接口都是/api/xxxxxx")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("              "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//比如我现在请求的是/api/student,但是我真正的接口资源路径是/student,前面是没有api的")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这里的作用就是帮我最后真正请求的时候把这个/api过滤掉")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);