<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>http | 前端小站</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/website/blog/assets/favicon.ico">
    <script type="text/javascript" src="https://cms.hs.net/r/cms/www/itn/js/userAnalysis.js?appkey=NjRfMQ==" async="true" id="user_analysis_id"></script>
    <meta name="description" content="~">
    <link rel="preload" href="/website/blog/assets/css/0.styles.edf1fc31.css" as="style"><link rel="preload" href="/website/blog/assets/js/app.a3a72a23.js" as="script"><link rel="preload" href="/website/blog/assets/js/7.e5a4a7de.js" as="script"><link rel="preload" href="/website/blog/assets/js/41.8382649d.js" as="script"><link rel="preload" href="/website/blog/assets/js/37.133e5c9b.js" as="script"><link rel="prefetch" href="/website/blog/assets/js/1.35396e1f.js"><link rel="prefetch" href="/website/blog/assets/js/10.bcb9a348.js"><link rel="prefetch" href="/website/blog/assets/js/11.026d1919.js"><link rel="prefetch" href="/website/blog/assets/js/12.00d4c28a.js"><link rel="prefetch" href="/website/blog/assets/js/13.4681dd7d.js"><link rel="prefetch" href="/website/blog/assets/js/14.08665e8c.js"><link rel="prefetch" href="/website/blog/assets/js/15.74c3e15f.js"><link rel="prefetch" href="/website/blog/assets/js/16.360f2fb7.js"><link rel="prefetch" href="/website/blog/assets/js/17.fa7d626a.js"><link rel="prefetch" href="/website/blog/assets/js/18.13be786d.js"><link rel="prefetch" href="/website/blog/assets/js/19.23680e51.js"><link rel="prefetch" href="/website/blog/assets/js/2.664274c1.js"><link rel="prefetch" href="/website/blog/assets/js/20.55f3b4e3.js"><link rel="prefetch" href="/website/blog/assets/js/21.8942f4b2.js"><link rel="prefetch" href="/website/blog/assets/js/22.da67ecd7.js"><link rel="prefetch" href="/website/blog/assets/js/23.a89b2b02.js"><link rel="prefetch" href="/website/blog/assets/js/24.723a2bd9.js"><link rel="prefetch" href="/website/blog/assets/js/25.82636da4.js"><link rel="prefetch" href="/website/blog/assets/js/26.af7c40cb.js"><link rel="prefetch" href="/website/blog/assets/js/27.fe4378f8.js"><link rel="prefetch" href="/website/blog/assets/js/28.6f0890d5.js"><link rel="prefetch" href="/website/blog/assets/js/29.6ad4a457.js"><link rel="prefetch" href="/website/blog/assets/js/3.742a7a1e.js"><link rel="prefetch" href="/website/blog/assets/js/30.db2ce232.js"><link rel="prefetch" href="/website/blog/assets/js/31.f991e740.js"><link rel="prefetch" href="/website/blog/assets/js/32.d56dfaeb.js"><link rel="prefetch" href="/website/blog/assets/js/33.93d46f6d.js"><link rel="prefetch" href="/website/blog/assets/js/34.dbe81cd4.js"><link rel="prefetch" href="/website/blog/assets/js/35.7e04ba1f.js"><link rel="prefetch" href="/website/blog/assets/js/36.333b4a68.js"><link rel="prefetch" href="/website/blog/assets/js/38.b648ba2e.js"><link rel="prefetch" href="/website/blog/assets/js/39.bb2de192.js"><link rel="prefetch" href="/website/blog/assets/js/4.cf14bc38.js"><link rel="prefetch" href="/website/blog/assets/js/40.b84b3c27.js"><link rel="prefetch" href="/website/blog/assets/js/42.78f45b6f.js"><link rel="prefetch" href="/website/blog/assets/js/43.bc8e996f.js"><link rel="prefetch" href="/website/blog/assets/js/44.32ff1f37.js"><link rel="prefetch" href="/website/blog/assets/js/45.00a4e919.js"><link rel="prefetch" href="/website/blog/assets/js/46.da24a6dc.js"><link rel="prefetch" href="/website/blog/assets/js/47.02039f2b.js"><link rel="prefetch" href="/website/blog/assets/js/48.5f0e9777.js"><link rel="prefetch" href="/website/blog/assets/js/49.2cf784f8.js"><link rel="prefetch" href="/website/blog/assets/js/5.64482bde.js"><link rel="prefetch" href="/website/blog/assets/js/50.fa36e0f8.js"><link rel="prefetch" href="/website/blog/assets/js/51.e2e5684c.js"><link rel="prefetch" href="/website/blog/assets/js/52.a12ef1d5.js"><link rel="prefetch" href="/website/blog/assets/js/53.c582a61e.js"><link rel="prefetch" href="/website/blog/assets/js/54.ac2b27cf.js"><link rel="prefetch" href="/website/blog/assets/js/55.6e071d4d.js"><link rel="prefetch" href="/website/blog/assets/js/56.44fc7909.js"><link rel="prefetch" href="/website/blog/assets/js/57.973853d7.js"><link rel="prefetch" href="/website/blog/assets/js/58.0b14490d.js"><link rel="prefetch" href="/website/blog/assets/js/59.d8341454.js"><link rel="prefetch" href="/website/blog/assets/js/60.082bbb11.js"><link rel="prefetch" href="/website/blog/assets/js/61.b40fb1a3.js"><link rel="prefetch" href="/website/blog/assets/js/62.b56b6e4e.js"><link rel="prefetch" href="/website/blog/assets/js/63.f43a14f1.js"><link rel="prefetch" href="/website/blog/assets/js/64.c72507b6.js"><link rel="prefetch" href="/website/blog/assets/js/65.f0243d3f.js"><link rel="prefetch" href="/website/blog/assets/js/66.261504f6.js"><link rel="prefetch" href="/website/blog/assets/js/67.61e74772.js"><link rel="prefetch" href="/website/blog/assets/js/68.f7b0033e.js"><link rel="prefetch" href="/website/blog/assets/js/69.603629eb.js"><link rel="prefetch" href="/website/blog/assets/js/70.6c5b77e6.js"><link rel="prefetch" href="/website/blog/assets/js/71.17b1bc7e.js"><link rel="prefetch" href="/website/blog/assets/js/72.34498702.js"><link rel="prefetch" href="/website/blog/assets/js/73.bbc68441.js"><link rel="prefetch" href="/website/blog/assets/js/74.98205159.js"><link rel="prefetch" href="/website/blog/assets/js/75.e371fe5b.js"><link rel="prefetch" href="/website/blog/assets/js/76.e25ba37c.js"><link rel="prefetch" href="/website/blog/assets/js/77.d788a878.js"><link rel="prefetch" href="/website/blog/assets/js/78.a71420c7.js"><link rel="prefetch" href="/website/blog/assets/js/79.ddffbdfc.js"><link rel="prefetch" href="/website/blog/assets/js/8.fc7de73c.js"><link rel="prefetch" href="/website/blog/assets/js/80.cc3773c6.js"><link rel="prefetch" href="/website/blog/assets/js/81.7c76945f.js"><link rel="prefetch" href="/website/blog/assets/js/82.a6809757.js"><link rel="prefetch" href="/website/blog/assets/js/9.4adbc6f5.js">
    <link rel="stylesheet" href="/website/blog/assets/css/0.styles.edf1fc31.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/website/blog/" class="home-link router-link-active"><img src="/website/blog/assets/logo.png" alt="前端小站" class="logo"> <span class="site-name can-hide">前端小站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/website/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/website/blog/component/api/tree.html" class="nav-link">
  组件
</a></div><div class="nav-item"><a href="/website/blog/javascript/闭包/闭包.html" class="nav-link">
  js
</a></div><div class="nav-item"><a href="/website/blog/vue/mvc&amp;&amp;mvvm.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/website/blog/browser/进程.html" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/website/blog/network/http.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  网络
</a></div><div class="nav-item"><a href="/website/blog/webpack/webpack.html" class="nav-link">
  webpack
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/website/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/website/blog/component/api/tree.html" class="nav-link">
  组件
</a></div><div class="nav-item"><a href="/website/blog/javascript/闭包/闭包.html" class="nav-link">
  js
</a></div><div class="nav-item"><a href="/website/blog/vue/mvc&amp;&amp;mvvm.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/website/blog/browser/进程.html" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/website/blog/network/http.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  网络
</a></div><div class="nav-item"><a href="/website/blog/webpack/webpack.html" class="nav-link">
  webpack
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/website/blog/network/http.html" aria-current="page" class="active sidebar-link">http</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#http0-9" class="sidebar-link">http0.9</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#http1-0-短链接" class="sidebar-link">http1.0 短链接</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#http1-1-长连接" class="sidebar-link">http1.1 长连接</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#http2" class="sidebar-link">http2</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#quic协议" class="sidebar-link">QUIC协议</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#http优化思路" class="sidebar-link">http优化思路</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#http-1-1优化机制" class="sidebar-link">HTTP/1.1优化机制</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#https" class="sidebar-link">https</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#https-三次握手" class="sidebar-link">https 三次握手</a></li><li class="sidebar-sub-header"><a href="/website/blog/network/http.html#中间人攻击" class="sidebar-link">中间人攻击</a></li></ul></li><li><a href="/website/blog/network/TCP协议.html" class="sidebar-link">TCP协议</a></li><li><a href="/website/blog/network/XHR.html" class="sidebar-link">XHR</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http"><a href="#http" class="header-anchor">#</a> http</h1> <h2 id="http0-9"><a href="#http0-9" class="header-anchor">#</a> http0.9</h2> <p>1991年提出的，支持简单的纯文本html页面请求</p> <ul><li>只有请求行，没有请求头、请求体</li> <li>服务器也没有响应头信息</li> <li>返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件(html,没有js,css等文件的加载)</li></ul> <h2 id="http1-0-短链接"><a href="#http1-0-短链接" class="header-anchor">#</a> http1.0 短链接</h2> <p>背景：</p> <div class="language-js extra-class"><pre class="language-js"><code>accept<span class="token operator">:</span> text<span class="token operator">/</span>html <span class="token comment">// 希望请求文件的类型</span>
accept<span class="token operator">-</span>encoding<span class="token operator">:</span> gzip<span class="token punctuation">,</span> deflate<span class="token punctuation">,</span> br <span class="token comment">// 可接受的数据压缩发哪个是你</span>
accept<span class="token operator">-</span>Charset<span class="token operator">:</span> <span class="token constant">ISO</span><span class="token operator">-</span><span class="token number">8859</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>utf<span class="token operator">-</span><span class="token number">8</span> <span class="token comment">// 编码方式</span>
accept<span class="token operator">-</span>language<span class="token operator">:</span> zh<span class="token operator">-</span><span class="token constant">CN</span><span class="token punctuation">,</span>zh

</code></pre></div><ul><li>由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。 accept</li> <li>单个文件的数据量也变得越来越大，为了减轻传输性能，以浏览器需要知道服务器压缩的方法。 accept-encoding: gzip, deflate, br</li> <li>由于万维网的全球性，支持不同国家的语言。 accept-language</li></ul> <p>总结：</p> <ul><li>引入了请求头、响应头，以key-value形式保存，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息</li> <li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了<code>状态码</code>。状态码是通过响应行的方式来通知浏览器的</li> <li>为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。</li> <li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了<code>用户代理</code>的字段。</li></ul> <p>特点：</p> <ol><li><p>短链接：常规http请求，一个TCP连接中同时只能由一个http请求</p></li> <li><p>缓存处理：<code>If-Modified-Since</code> <code>Expires</code>作为缓存判断标准</p></li> <li><p><code>线头阻塞</code> head of line blocking</p></li></ol> <h2 id="http1-1-长连接"><a href="#http1-1-长连接" class="header-anchor">#</a> http1.1 长连接</h2> <ol><li><p>支持持久化链接</p> <ul><li>contention: keep-alive 实现了长连接 PersistentConnection，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点；</li> <li>特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</li> <li>contention: close 关闭持久链接，<code>目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接</code></li></ul></li> <li><p>支持http管道</p> <ul><li>HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中，而在发送过程中不需要等待服务器对前一个请求的响应</li> <li>只不过，客户端还是需要按照http发送请求的顺序来接受响应。即客户端可以并行，服务端串行</li> <li>由于http请求的时间是不确定的，可能会造成后续http请求阻塞，就可能会造成 <code>队头阻塞</code></li></ul></li> <li><p>提供虚拟主机的支持</p> <ul><li>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</li> <li>HTTP/1.1 的请求头中增加了 <code>Host</code> 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</li></ul></li> <li><p>对动态生成的内容提供了完美支持</p> <ul><li>HTTP/1.0 通过 <code>content-type</code> 可以提前判断字节数</li> <li>HTTP/1.1 通过引入 <code>Chunk transfer</code> 机制（<code>分块传输</code>）来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持</li></ul></li> <li><p>客户端 Cookie、安全机制</p></li> <li><p>缓存处理：<code>If-Not-Match/Etag</code>，<code>cache-control</code></p></li></ol> <h3 id="http-1-1-的主要问题"><a href="#http-1-1-的主要问题" class="header-anchor">#</a> HTTP/1.1 的主要问题</h3> <p>对带宽的利用率却并不理想，带宽是指每秒最大能发送或者接收的字节数</p> <ul><li>TCP 的慢启动</li> <li>同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽</li> <li>HTTP/1.1 队头阻塞的问题</li></ul> <h2 id="http2"><a href="#http2" class="header-anchor">#</a> http2</h2> <p>在http/2提出之前，chrome在2012年提出了 <code>SPDY</code>方法，针对http1.1，推出多路复用，设置请求头优先级，header压缩，server推送，server暗示</p> <p><code>HTTP/2和SPDY不同的地方在于，它是业界标准，而SPDY是chrome自家的孩子，马虎不得，一言一行都得考虑明星效应</code></p> <p>背景：HTTP/2 的思路就是，实现一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要<code>一次慢启动</code>，<code>同时也避免了多个 TCP 连接竞争带宽所带来的问题</code>，同时<code>实现资源的并行请求</code>，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器，这样就解决了http1.1队头阻塞的问题</p> <h3 id="多路复用机制"><a href="#多路复用机制" class="header-anchor">#</a> 多路复用机制</h3> <p><img src="/website/blog/assets/img/http2.86cdf01a.png" alt="avatar"></p> <ol><li><p>流程</p> <p><code>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术</code>，二进制帧为HTTP/2的“基本单位”</p> <p>把HTTP/1.x每个请求都当作一个“流”，那么请求化成多个流，请求响应数据切成多个帧，不同流中的帧交错地发送给对方，这就是HTTP/2中的多路复用</p> <ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li> <li>这些数据经过<code>二进制分帧层</code>处理之后，会被转换为一个个带有请求 <code>ID 编号</code>的帧，通过协议栈将这些帧发送给服务器。</li> <li>服务器接收到所有帧之后，会将所有<code>相同 ID 的帧合并为一条完整的请求信息</code>。</li> <li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至<code>二进制分帧层</code>。</li> <li>同样，<code>二进制分帧层</code>会将这些响应数据<code>转换</code>为一个个带有请求 <code>ID 编号</code>的帧，经过协议栈发送给浏览器。</li> <li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求；根据相同ID编号的帧组装成一个完整的数据</li></ul></li> <li><p>其他特性</p> <ul><li>设置请求头的顺序。服务器端可以根据页面的优先级，设置优先返回那些关键的资源</li> <li>服务器推送(server push)。针对首屏优化有比较好的提升。比如当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</li> <li>头部压缩。重点正对post请求体发送，针对请求头，响应头做压缩的处理</li></ul></li> <li><p>缺点</p> <ul><li>tcp协议的数据流传输过程中的 <code>队头阻塞</code>。 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会<code>阻塞该 TCP 连接中的所有请求</code>，所以随着<code>丢包率</code>的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</li> <li>TCP 建立连接的延时</li> <li>TCP 协议僵化</li></ul></li></ol> <h2 id="quic协议"><a href="#quic协议" class="header-anchor">#</a> QUIC协议</h2> <p>全新的协议，独立于http协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能</p> <ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li> <li>集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</li> <li>实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流</li></ul> <h2 id="http优化思路"><a href="#http优化思路" class="header-anchor">#</a> http优化思路</h2> <p>影响一个 HTTP 网络请求的因素主要有两个：<code>带宽</code>和<code>延迟</code>。</p> <ul><li><p>带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p></li> <li><p>延迟：</p> <ul><li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li> <li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li> <li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ul></li></ul> <h2 id="http-1-1优化机制"><a href="#http-1-1优化机制" class="header-anchor">#</a> HTTP/1.1优化机制</h2> <p>增加了持久连接；
浏览器为每个域名最多同时维护 6 个 TCP 持久连接；
使用 CDN 的实现域名分片机制。</p> <ol><li>Spriting（图片合并）：但有时候只需要其中一张小图，就会浪费流量</li> <li>Inlining（内容内嵌）：比如把图片转化为base64编码后内嵌到总文件中，问题同上</li> <li>Concatenation（文件合并）：粒度变大，一个小的js代码改动会导致整个js文件被下载</li> <li>Domain Sharding（域名分片）：浏览器或者客户端是根据domain（域名）来建立连接，多建立几个sub domain（子域名），那么同时可以建立的http请求就会更多，连接数变多之后，受限制的请求就不需要等待前面的请求完成才能发出了；只有在请求数非常之多的场景下才有明显的效果，移动端建议不要使用</li></ol> <h2 id="https"><a href="#https" class="header-anchor">#</a> https</h2> <p>HTTPS 保证了<code>传输安全</code>，防止传输过程被<code>监听</code>、防止<code>数据被窃取</code>，可以确认网站的真实性。</p> <p>在http协议栈中添加了 一个 安全层（SSL/TLS）</p> <p>HTTPS 使用了对称和非对称的混合加密方式，这解决了数据传输安全的问题；</p> <p>HTTPS 引入了中间机构 CA，CA 通过给服务器颁发数字证书，解决了浏览器对服务器的信任问题</p> <ul><li><p>数据的安全传输</p> <ul><li>采用的是混合加密的机制，</li> <li><code>对称加密的方式加密传输数据</code> <ul><li>通过 client random + server random + pre-master 加密生成 master-secert(会话公钥)</li></ul></li> <li><code>非对称加密的方式来传输密钥</code> <ul><li>pre-master非对称加密传输的</li> <li>浏览器端 通过 公钥 对 pre-master  加密 （通过client random + server random +  公钥解密）</li> <li>服务端 通过 私钥 对 pre-master 解密
-采用 <code>master-secert（会话秘钥） 加密数据传输</code> 这种方式虽然能保证<code>数据的安全传输</code>，但是依然没办法证明服务器是可靠的</li></ul></li></ul></li> <li><p>验证身份: 防止”中间人“攻击，同时可以为网站提供身份证明。</p> <ul><li>入了数字证书，<code>数字证书是由 CA 签名过的</code>，所以浏览器能够验证该证书的可靠性</li></ul></li></ul> <p><img src="/website/blog/assets/img/https.77c852ff.png" alt="avatar"></p> <h2 id="https-三次握手"><a href="#https-三次握手" class="header-anchor">#</a> https 三次握手</h2> <ol><li>Client发送 random1 + 加密算法列表 到 Server</li> <li>Server接受到信息后，返回 random2 + 返回确认后的加密算法 + 服务器的数字证书 + 确认的密码套件列表</li> <li>Client验证证书的有效性后，发送 由 random1+random2 生成的 pre-random 通过服务器的公钥加密 发送到 服务器</li> <li>Server接收到per-master， random1+random2+per-master（解密后）生成 master-secret（会话秘钥），然后发送预定成功，服务器握手结束通知，表示服务器的握手阶段已经结束</li> <li>Client收到生成同样的master-secert，对称加密秘钥传输完毕</li></ol> <h2 id="中间人攻击"><a href="#中间人攻击" class="header-anchor">#</a> 中间人攻击</h2> <p>中间人 (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制. <code>在中间人攻击中, 攻击者可以拦截通讯双方的通话并插入新的内容。</code></p> <p>一般的过程如下：</p> <ol><li>客户端发送请求到服务端，请求被中间人截获</li> <li>服务器向客户端发送公钥</li> <li>中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端</li> <li>客户端收到伪造的公钥后，生成加密hash值发给服务器</li> <li>中间人获得加密hash值，用自己的私钥解密获得真秘钥,同时生成假的加密hash值，发给服务器</li> <li>务器用私钥解密获得假密钥,然后加密数据传输给客户端</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/website/blog/assets/js/app.a3a72a23.js" defer></script><script src="/website/blog/assets/js/7.e5a4a7de.js" defer></script><script src="/website/blog/assets/js/41.8382649d.js" defer></script><script src="/website/blog/assets/js/37.133e5c9b.js" defer></script>
  </body>
</html>
